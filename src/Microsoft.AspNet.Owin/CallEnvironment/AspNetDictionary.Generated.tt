<#@ template language="C#" #>
<#@ assembly name="System.Core.dll" #>
<#@ import namespace="System.Linq" #>
<#
var props = new[]
{
// owin standard keys
  new {Key="owin.Version", Type="string", Name="OwinVersion"},
  new {Key="owin.CallCancelled", Type="CancellationToken", Name="CallCancelled"},

  new {Key="owin.RequestProtocol", Type="string", Name="RequestProtocol"},
  new {Key="owin.RequestMethod", Type="string", Name="RequestMethod"},
  new {Key="owin.RequestScheme", Type="string", Name="RequestScheme"},
  new {Key="owin.RequestPathBase", Type="string", Name="RequestPathBase"},
  new {Key="owin.RequestPath", Type="string", Name="RequestPath"},
  new {Key="owin.RequestQueryString", Type="string", Name="RequestQueryString"},
  new {Key="owin.RequestHeaders", Type="IDictionary<string, string[]>", Name="RequestHeaders"},
  new {Key="owin.RequestBody", Type="Stream", Name="RequestBody"},

  new {Key="owin.ResponseStatusCode", Type="int", Name="ResponseStatusCode"},
  new {Key="owin.ResponseReasonPhrase", Type="string", Name="ResponseReasonPhrase"},
  new {Key="owin.ResponseHeaders", Type="IDictionary<string, string[]>", Name="ResponseHeaders"},
  new {Key="owin.ResponseBody", Type="Stream", Name="ResponseBody"},
  
// defacto host keys
  new {Key="host.TraceOutput", Type="TextWriter", Name="HostTraceOutput"},
  new {Key="host.AppName", Type="string", Name="HostAppName"},
  new {Key="server.DisableResponseBuffering", Type="Action", Name="ServerDisableResponseBuffering"},
  new {Key="server.User", Type="System.Security.Principal.IPrincipal", Name="ServerUser"},
  new {Key="server.OnSendingHeaders", Type="Action<Action<object>, object>", Name="OnSendingHeaders"},
  new {Key="server.Capabilities", Type="IDictionary<string, object>", Name="ServerCapabilities"},

// ServerVariable keys
  new {Key="server.RemoteIpAddress", Type="string", Name="ServerRemoteIpAddress"},
  new {Key="server.RemotePort", Type="string", Name="ServerRemotePort"},
  new {Key="server.LocalIpAddress", Type="string", Name="ServerLocalIpAddress"},
  new {Key="server.LocalPort", Type="string", Name="ServerLocalPort"},
  new {Key="server.IsLocal", Type="bool", Name="ServerIsLocal"},
  
// SSL
  new { Key="ssl.ClientCertificate", Type="X509Certificate", Name="ClientCert" },
  new { Key="ssl.LoadClientCertAsync", Type="Func<Task>", Name="LoadClientCert" },

// SendFile keys
  new {Key="sendfile.SendAsync", Type="Func<string, long, long?, Task>", Name="SendFileAsync"},

// WebSocket keys
  new {Key="websocket.Accept", Type="object", Name="WebSocketAccept"},

// aspnet-specific keys
  new {Key="System.Web.Routing.RequestContext", Type="RequestContext", Name="RequestContext"},
  new {Key="System.Web.HttpContextBase", Type="HttpContextBase", Name="HttpContextBase"},

}.Select((prop, Index)=>new {prop.Key, prop.Type, prop.Name, Index});

var lengths = props.GroupBy(prop=>prop.Key.Length);


Func<int,string> IsSet = Index => "((_flag" + (Index / 32) + " & 0x" + (1<<(Index % 32)).ToString("x") + "u) != 0)";
Func<int,string> Set = Index => "_flag" + (Index / 32) + " |= 0x" + (1<<(Index % 32)).ToString("x") + "u";
Func<int,string> Clear = Index => "_flag" + (Index / 32) + " &= ~0x" + (1<<(Index % 32)).ToString("x") + "u";
#>
//-----------------------------------------------------------------------
// <copyright>
//   Copyright (c) Katana Contributors. All rights reserved.
// </copyright>
//-----------------------------------------------------------------------
// <auto-generated />

using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Security.Cryptography.X509Certificates;
using System.Threading;
using System.Threading.Tasks;
using System.Web;
using System.Web.Routing;

namespace Microsoft.AspNet.Owin.CallEnvironment
{
    public partial class AspNetDictionary
    {
        private UInt32 _flag0;

<# foreach(var prop in props) { #>
        private <#=prop.Type#> _<#=prop.Name#>;
<# } #>

<# foreach(var prop in props) { #>
        public <#=prop.Type#> <#=prop.Name#> 
        {
            get { return _<#=prop.Name#>; }
            set 
            {
                <#=Set(prop.Index)#>;
                _<#=prop.Name#> = value;
            }
        }

<# } #>
        private bool PropertiesContainsKey(string key)
        {
            switch (key.Length)
            {
<# foreach(var length in lengths) { #>
                case <#=length.Key#>:
<# foreach(var prop in length) { #>
                    if (<#=IsSet(prop.Index)#> && string.Equals(key, "<#=prop.Key#>", StringComparison.Ordinal)) 
                    {
                        return true;
                    }
<# } #>
                   break;
<# } #>
            }
            return false;
        }

        private bool PropertiesTryGetValue(string key, out object value)
        {
            switch (key.Length)
            {
<# foreach(var length in lengths) { #>
                case <#=length.Key#>:
<# foreach(var prop in length) { #>
                    if (<#=IsSet(prop.Index)#> && string.Equals(key, "<#=prop.Key#>", StringComparison.Ordinal)) 
                    {
                        value = <#=prop.Name#>;
                        return true;
                    }
<# } #>
                   break;
<# } #>
            }
            value = null;
            return false;
        }

        private bool PropertiesTrySetValue(string key, object value)
        {
            switch (key.Length)
            {
<# foreach(var length in lengths) { #>
                case <#=length.Key#>:
<# foreach(var prop in length) { #>
                    if (string.Equals(key, "<#=prop.Key#>", StringComparison.Ordinal)) 
                    {
                        <#=Set(prop.Index)#>;
                        <#=prop.Name#> = (<#=prop.Type#>)value;
                        return true;
                    }
<# } #>
                   break;
<# } #>
            }
            return false;
        }

        private bool PropertiesTryRemove(string key)
        {
            switch (key.Length)
            {
<# foreach(var length in lengths) { #>
                case <#=length.Key#>:
<# foreach(var prop in length) { #>
                    if (<#=IsSet(prop.Index)#> && string.Equals(key, "<#=prop.Key#>", StringComparison.Ordinal)) 
                    {
                        <#=Clear(prop.Index)#>;
                        <#=prop.Name#> = default(<#=prop.Type#>);
                        return true;
                    }
<# } #>
                   break;
<# } #>
            }
            return false;
        }

        private IEnumerable<string> PropertiesKeys()
        {
<# foreach(var prop in props) { #>
            if (<#=IsSet(prop.Index)#>)
            {
                yield return "<#=prop.Key#>";
            }
<# } #>
        }

        private IEnumerable<object> PropertiesValues()
        {
<# foreach(var prop in props) { #>
            if (<#=IsSet(prop.Index)#>)
            {
                yield return <#=prop.Name#>;
            }
<# } #>
        }

        private IEnumerable<KeyValuePair<string, object>> PropertiesEnumerable()
        {
<# foreach(var prop in props) { #>
            if (<#=IsSet(prop.Index)#>)
            {
                yield return new KeyValuePair<string, object>("<#=prop.Key#>", <#=prop.Name#>);
            }
<# } #>
        }
    }
}
